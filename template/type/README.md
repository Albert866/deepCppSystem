# CPP 常用类型的使用方式总结

---

## std::pair 类型

- 将两个对象组合成一个对象，两个对象可以是同一类型或不同类型
- C++17 之前，支持模版函数自动推导: `auto kv = std::make_pair(100, "Cpp"s);`
- C++17 及之后，支持构造函数参数类型推导: `std::pair kv{100, "Cpp"s}`
- std::pair 支持拷贝、移动、析构，是对 first and second 的委托调用

## std::tuple 类型

- 标准库类型 std::tuple 是一个通用的元组类，可以存储多个不同类型的值
- std::tuple 是一个变参模版类，可以存储任意数量的值，支持自动类型推导，通过 std::get<> 获取元素
- C++17 之前，支持模版函数自动推导: `auto tp = std::make_tuple(100, "Cpp"s);` 使用 `int id = std::get<0>(tp)` 获取第一个元素;
- C++17 之后，支持构造函数参数类型推导: `std::tuple tp{100, 3.14, "Cpp"s}` 使用 `string lang = std::get<2>(tp)` 获取第一个元素;
- std::tuple 支持拷贝、移动、析构，是对其内各个元素的委托调用

## std::optional 类型

- C++17 引入的 std::optional 类型，是一个可选值的容器，可以存储一个值或者没有值, 通过一个内部的 bool 类型的标志位来表示是否有值
- std::optional 内存结构中，除了其内存储值对象大小外，还会存储一个 bool 类型的标志位，用于标识是否有值
- std::optional 支持模版函数自动推导: `auto opt = std::make_optional(100);`, 可以使用 `*, ->, value(), value_or()` 等方法获取值
- std::optional 支持拷贝、移动、析构，是对其内部值的委托调用

## std::variant 类型

- 使用模版参数，存储多个强类型参数中的一个，可以存储任意类型的值，但只能存储其中一个
- 搭配 std::visit 访问器，可以访问 std::variant 中的值, 并且支持对类型的多态访问
- 内存模型：最大的类型大小，加上一个额外的 8Byte 索引，用于标识当前存储的类型, 无需额外的堆内存分配

## std::any 类型

- std::any 可以存储任何支持拷贝构造函数的类型，包括自定义类型
- std::any 使用的是小对象优化的内存模型，小对象存储在栈上，大对象存储在堆上，并使用 RAII 机制管理内存
- 注意：尽量避免使用 std::any, 特别是存储基本类型，因为会有额外的内存分配和释放，有缓存折损
